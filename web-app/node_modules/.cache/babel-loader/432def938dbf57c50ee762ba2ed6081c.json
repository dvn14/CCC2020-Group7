{"ast":null,"code":"import { Path, withLeaflet } from 'react-leaflet';\nimport { GeoJSON } from 'leaflet';\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** `Object#toString` result references. */\n\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    nullTag = '[object Null]',\n    proxyTag = '[object Proxy]',\n    undefinedTag = '[object Undefined]';\n/** Detect free variable `global` from Node.js. */\n\nvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n/** Detect free variable `self`. */\n\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal || freeSelf || Function('return this')();\n/** Used for built-in method references. */\n\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar nativeObjectToString = objectProto.toString;\n/** Built-in value references. */\n\nvar Symbol$1 = root.Symbol,\n    symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\n\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\n\n\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\n\n\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\n\n\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  } // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\n\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\n\n\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar lodash_isfunction = isFunction;\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/**\n * GeoJSON supported fillPattern style\n */\n\n\nvar GeoJSONFillable = function (_Path) {\n  inherits(GeoJSONFillable, _Path);\n\n  function GeoJSONFillable() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GeoJSONFillable);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GeoJSONFillable.__proto__ || Object.getPrototypeOf(GeoJSONFillable)).call.apply(_ref, [this].concat(args))), _this), _this.addedNotExistedPatterns = function (layers, style) {\n      var map = _this.props.leaflet.map;\n      if (!style) return;\n      if (lodash_isfunction(style)) layers.forEach(function (layer) {\n        var featureStyle = style(layer.feature);\n\n        if (featureStyle.fillPattern && !map.hasPattern(featureStyle.fillPattern)) {\n          map.once('patternadd', function (_ref2) {\n            var pattern = _ref2.pattern; // console.log('added', pattern, layer);\n\n            setTimeout(function () {\n              return layer.setStyle({\n                fillPattern: pattern\n              });\n            }, 0);\n          });\n          map.addPattern(featureStyle.fillPattern);\n        }\n      });else if (style.fillPattern) {\n        _this.addPatternToLayer(style.fillPattern, _this);\n      }\n    }, _this.addPatternToLayer = function (pattern, layer) {\n      var map = _this.props.leaflet.map;\n\n      if (!map.hasPattern(pattern)) {\n        map.once('patternadd', function (_ref3) {\n          var pattern = _ref3.pattern;\n          setTimeout(function () {\n            return layer.setStyle({\n              fillPattern: pattern\n            });\n          }, 0);\n        });\n        map.addPattern(pattern);\n      } else {\n        layer.setStyle({\n          fillPattern: pattern\n        });\n      }\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GeoJSONFillable, [{\n    key: 'createLeafletElement',\n    value: function createLeafletElement(props) {\n      var _this2 = this;\n\n      var el = new GeoJSON(props.data, this.getOptions(props));\n      el.once('add', function (e) {\n        _this2.addedNotExistedPatterns(e.target.getLayers(), props.style);\n      });\n      return el;\n    }\n  }, {\n    key: 'updateLeafletElement',\n    value: function updateLeafletElement(fromProps, toProps) {\n      if (lodash_isfunction(toProps.style)) {\n        this.addedNotExistedPatterns(this.leafletElement.getLayers(), toProps.style);\n        this.setStyle(toProps.style);\n      } else {\n        if (fromProps.style.fillPattern !== toProps.style.fillPattern) {\n          this.addPatternToLayer(toProps.style.fillPattern, this);\n        }\n\n        this.setStyleIfChanged(fromProps, toProps);\n      }\n    }\n  }]);\n  return GeoJSONFillable;\n}(Path);\n/** @component */\n\n\nvar GeoJSONFillable$1 = withLeaflet(GeoJSONFillable);\n/*\n Leaflet.pattern, Provides tools to set the backgrounds of vector shapes in Leaflet to be patterns.\n https://github.com/teastman/Leaflet.pattern\n (c) 2015, Tyler Eastman\n*/\n\nvar getId = function getId(value) {\n  var id = value.options.key || L.stamp(value);\n  return id;\n};\n\nvar L = window.L;\n\n(function (window, document, undefined) {\n  /*\n  * L.Pattern is the base class for fill patterns for leaflet Paths.\n  */\n  L.Pattern = L.Class.extend({\n    includes: L.Evented.prototype || L.Mixin.Events,\n    options: {\n      x: 0,\n      y: 0,\n      width: 8,\n      height: 8,\n      patternUnits: 'userSpaceOnUse',\n      patternContentUnits: 'userSpaceOnUse',\n      key: '' // angle: <0 - 360>\n      // patternTransform: <transform-list>\n\n    },\n    _addShapes: L.Util.falseFn,\n    _update: L.Util.falseFn,\n    initialize: function initialize(options) {\n      this._shapes = {};\n      if (!options.key) throw Error('Should define a unique option key');\n      L.setOptions(this, options);\n    },\n    onAdd: function onAdd(map) {\n      this._map = map.target ? map.target : map;\n\n      if (!this._map._initDefRoot) {\n        debugger;\n      }\n\n      this._map._initDefRoot(); // Create the DOM Object for the pattern.\n\n\n      this._initDom(); // Any shapes that were added before this was added to the map need to have their onAdd called.\n\n\n      for (var i in this._shapes) {\n        this._shapes[i].onAdd(this);\n      } // Call any children that want to add their own shapes.\n\n\n      this._addShapes(); // Add the DOM Object to the DOM Tree\n\n\n      this._addDom();\n\n      this.redraw();\n\n      if (this.getEvents) {\n        this._map.on(this.getEvents(), this);\n      }\n\n      this.fire('add');\n\n      this._map.fire('patternadd', {\n        pattern: this\n      });\n    },\n    onRemove: function onRemove() {\n      this._removeDom();\n    },\n    redraw: function redraw() {\n      if (this._map) {\n        this._update();\n\n        for (var i in this._shapes) {\n          this._shapes[i].redraw();\n        }\n      }\n\n      return this;\n    },\n    setStyle: function setStyle(style) {\n      L.setOptions(this, style);\n\n      if (this._map) {\n        this._updateStyle();\n\n        this.redraw();\n      }\n\n      return this;\n    },\n    addTo: function addTo(map) {\n      map.addPattern(this);\n      return this;\n    },\n    remove: function remove() {\n      return this.removeFrom(this._map);\n    },\n    removeFrom: function removeFrom(map) {\n      if (map) {\n        map.removePattern(this);\n      }\n\n      return this;\n    }\n  });\n  L.Map.addInitHook(function () {\n    this._patterns = {};\n  });\n  L.Map.include({\n    addPattern: function addPattern(pattern) {\n      var id = getId(pattern);\n\n      if (this._patterns[id]) {\n        return pattern;\n      }\n\n      this._patterns[id] = pattern;\n      this.whenReady(pattern.onAdd, pattern);\n      return this;\n    },\n    removePattern: function removePattern(pattern) {\n      var id = getId(pattern);\n\n      if (!this._patterns[id]) {\n        return this;\n      }\n\n      if (this._loaded) {\n        pattern.onRemove(this);\n      }\n\n      if (pattern.getEvents) {\n        this.off(pattern.getEvents(), pattern);\n      }\n\n      delete this._patterns[id];\n\n      if (this._loaded) {\n        this.fire('patternremove', {\n          pattern: pattern\n        });\n        pattern.fire('remove');\n      }\n\n      pattern._map = null;\n      return this;\n    },\n    hasPattern: function hasPattern(pattern) {\n      return !!pattern && getId(pattern) in this._patterns;\n    }\n  });\n  L.Pattern.SVG_NS = 'http://www.w3.org/2000/svg';\n  L.Pattern = L.Pattern.extend({\n    _createElement: function _createElement(name) {\n      return document.createElementNS(L.Pattern.SVG_NS, name);\n    },\n    _initDom: function _initDom() {\n      this._dom = this._createElement('pattern');\n\n      if (this.options.className) {\n        L.DomUtil.addClass(this._dom, this.options.className);\n      }\n\n      this._updateStyle();\n    },\n    _addDom: function _addDom() {\n      this._map._defRoot.appendChild(this._dom);\n    },\n    _removeDom: function _removeDom() {\n      L.DomUtil.remove(this._dom);\n    },\n    _updateStyle: function _updateStyle() {\n      var dom = this._dom;\n      var options = this.options;\n\n      if (!dom) {\n        return;\n      }\n\n      dom.setAttribute('id', getId(this));\n      dom.setAttribute('x', options.x);\n      dom.setAttribute('y', options.y);\n      dom.setAttribute('width', options.width);\n      dom.setAttribute('height', options.height);\n      dom.setAttribute('patternUnits', options.patternUnits);\n      dom.setAttribute('patternContentUnits', options.patternContentUnits);\n\n      if (options.patternTransform || options.angle) {\n        var transform = options.patternTransform ? options.patternTransform + ' ' : '';\n        transform += options.angle ? 'rotate(' + options.angle + ') ' : '';\n        dom.setAttribute('patternTransform', transform);\n      } else {\n        dom.removeAttribute('patternTransform');\n      }\n\n      for (var i in this._shapes) {\n        this._shapes[i]._updateStyle();\n      }\n    }\n  });\n  L.Map.include({\n    _initDefRoot: function _initDefRoot() {\n      if (!this._defRoot) {\n        if (typeof this.getRenderer === 'function') {\n          var renderer = this.getRenderer(this);\n          this._defRoot = L.Pattern.prototype._createElement('defs');\n\n          renderer._container.appendChild(this._defRoot);\n        } else {\n          if (!this._pathRoot) {\n            this._initPathRoot();\n          }\n\n          this._defRoot = L.Pattern.prototype._createElement('defs');\n\n          this._pathRoot.appendChild(this._defRoot);\n        }\n      }\n    }\n  });\n\n  if (L.SVG) {\n    L.SVG.include({\n      _superUpdateStyle: L.SVG.prototype._updateStyle,\n      _updateStyle: function _updateStyle(layer) {\n        this._superUpdateStyle(layer);\n\n        if (layer.options.fill && layer.options.fillPattern) {\n          layer._path.setAttribute('fill', 'url(#' + getId(layer.options.fillPattern) + ')');\n        }\n      }\n    });\n  } else {\n    L.Path.include({\n      _superUpdateStyle: L.Path.prototype._updateStyle,\n      _updateStyle: function _updateStyle() {\n        this._superUpdateStyle();\n\n        if (this.options.fill && this.options.fillPattern) {\n          this._path.setAttribute('fill', 'url(#' + getId(this.options.fillPattern) + ')');\n        }\n      }\n    });\n  }\n  /*\n     * L.StripePattern is an implementation of Pattern that creates stripes.\n     */\n\n\n  L.StripePattern = L.Pattern.extend({\n    options: {\n      weight: 4,\n      spaceWeight: 4,\n      color: '#000000',\n      spaceColor: '#ffffff',\n      opacity: 1.0,\n      spaceOpacity: 0.0\n    },\n    _addShapes: function _addShapes() {\n      this._stripe = new L.PatternPath({\n        stroke: true,\n        weight: this.options.weight,\n        color: this.options.color,\n        opacity: this.options.opacity\n      });\n      this._space = new L.PatternPath({\n        stroke: true,\n        weight: this.options.spaceWeight,\n        color: this.options.spaceColor,\n        opacity: this.options.spaceOpacity\n      });\n      this.addShape(this._stripe);\n      this.addShape(this._space);\n\n      this._update();\n    },\n    _update: function _update() {\n      this._stripe.options.d = 'M0 ' + this._stripe.options.weight / 2 + ' H ' + this.options.width;\n      this._space.options.d = 'M0 ' + (this._stripe.options.weight + this._space.options.weight / 2) + ' H ' + this.options.width;\n    },\n    setStyle: L.Pattern.prototype.setStyle\n  });\n\n  L.stripePattern = function (options) {\n    return new L.StripePattern(options);\n  };\n  /*\n     * L.PatternShape is the base class that is used to define the shapes in Patterns.\n     */\n\n\n  L.PatternShape = L.Class.extend({\n    options: {\n      stroke: true,\n      color: '#3388ff',\n      weight: 3,\n      opacity: 1,\n      lineCap: 'round',\n      lineJoin: 'round',\n      // dashArray: null\n      // dashOffset: null\n      // fill: false\n      // fillColor: same as color by default\n      fillOpacity: 0.2,\n      fillRule: 'evenodd' // fillPattern: L.Pattern\n\n    },\n    initialize: function initialize(options) {\n      L.setOptions(this, options);\n    },\n    // Called when the parent Pattern get's added to the map,\n    // or when added to a Pattern that is already on the map.\n    onAdd: function onAdd(pattern) {\n      this._pattern = pattern;\n\n      if (this._pattern._dom) {\n        this._initDom(); // This function is implemented by it's children.\n\n\n        this._addDom();\n      }\n    },\n    addTo: function addTo(pattern) {\n      pattern.addShape(this);\n      return this;\n    },\n    redraw: function redraw() {\n      if (this._pattern) {\n        this._updateShape(); // This function is implemented by it's children.\n\n      }\n\n      return this;\n    },\n    setStyle: function setStyle(style) {\n      L.setOptions(this, style);\n\n      if (this._pattern) {\n        this._updateStyle();\n      }\n\n      return this;\n    },\n    setShape: function setShape(shape) {\n      this.options = L.extend({}, this.options, shape);\n\n      this._updateShape();\n    }\n  });\n  L.Pattern.include({\n    addShape: function addShape(shape) {\n      var id = getId(shape);\n\n      if (this._shapes[id]) {\n        return shape;\n      }\n\n      this._shapes[id] = shape;\n      shape.onAdd(this);\n    }\n  });\n  L.PatternShape.SVG_NS = 'http://www.w3.org/2000/svg';\n  L.PatternShape = L.PatternShape.extend({\n    _createElement: function _createElement(name) {\n      return document.createElementNS(L.PatternShape.SVG_NS, name);\n    },\n    _initDom: L.Util.falseFn,\n    _updateShape: L.Util.falseFn,\n    _initDomElement: function _initDomElement(type) {\n      this._dom = this._createElement(type);\n\n      if (this.options.className) {\n        L.DomUtil.addClass(this._dom, this.options.className);\n      }\n\n      this._updateStyle();\n    },\n    _addDom: function _addDom() {\n      this._pattern._dom.appendChild(this._dom);\n    },\n    _updateStyle: function _updateStyle() {\n      var dom = this._dom;\n      var options = this.options;\n\n      if (!dom) {\n        return;\n      }\n\n      if (options.stroke) {\n        dom.setAttribute('stroke', options.color);\n        dom.setAttribute('stroke-opacity', options.opacity);\n        dom.setAttribute('stroke-width', options.weight);\n        dom.setAttribute('stroke-linecap', options.lineCap);\n        dom.setAttribute('stroke-linejoin', options.lineJoin);\n\n        if (options.dashArray) {\n          dom.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          dom.removeAttribute('stroke-dasharray');\n        }\n\n        if (options.dashOffset) {\n          dom.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          dom.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        dom.setAttribute('stroke', 'none');\n      }\n\n      if (options.fill) {\n        if (options.fillPattern) {\n          dom.setAttribute('fill', 'url(#' + getId(options.fillPattern) + ')');\n        } else {\n          dom.setAttribute('fill', options.fillColor || options.color);\n        }\n\n        dom.setAttribute('fill-opacity', options.fillOpacity);\n        dom.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        dom.setAttribute('fill', 'none');\n      }\n\n      dom.setAttribute('pointer-events', options.pointerEvents || (options.interactive ? 'visiblePainted' : 'none'));\n    }\n  });\n  /*\n     * L.PatternPath is the implementation of PatternShape for adding Paths\n     */\n\n  L.PatternPath = L.PatternShape.extend({\n    //\toptions: {\n    // d: <svg path code>\n    //\t},\n    _initDom: function _initDom() {\n      this._initDomElement('path');\n    },\n    _updateShape: function _updateShape() {\n      if (!this._dom) {\n        return;\n      }\n\n      this._dom.setAttribute('d', this.options.d);\n    }\n  });\n  /*\n     * L.PatternCircle is the implementation of PatternShape for adding Circles\n     */\n\n  L.PatternCircle = L.PatternShape.extend({\n    options: {\n      x: 0,\n      y: 0,\n      radius: 0\n    },\n    _initDom: function _initDom() {\n      this._initDomElement('circle');\n    },\n    _updateShape: function _updateShape() {\n      if (!this._dom) {\n        return;\n      }\n\n      this._dom.setAttribute('cx', this.options.x);\n\n      this._dom.setAttribute('cy', this.options.y);\n\n      this._dom.setAttribute('r', this.options.radius);\n    }\n  });\n  /*\n     * L.PatternRect is the implementation of PatternShape for adding Rectangles\n     */\n\n  L.PatternRect = L.PatternShape.extend({\n    options: {\n      x: 0,\n      y: 0,\n      width: 10,\n      height: 10 // rx: x radius for rounded corners\n      // ry: y radius for rounded corners\n\n    },\n    _initDom: function _initDom() {\n      this._initDomElement('rect');\n    },\n    _updateShape: function _updateShape() {\n      if (!this._dom) {\n        return;\n      }\n\n      this._dom.setAttribute('x', this.options.x);\n\n      this._dom.setAttribute('y', this.options.y);\n\n      this._dom.setAttribute('width', this.options.width);\n\n      this._dom.setAttribute('height', this.options.height);\n\n      if (this.options.rx) {\n        this._dom.setAttribute('rx', this.options.rx);\n      }\n\n      if (this.options.ry) {\n        this._dom.setAttribute('ry', this.options.ry);\n      }\n    }\n  });\n  L.CheckerBoardPattern = L.Pattern.extend({\n    options: {\n      color: '#000000',\n      fillOpacity: 1\n    },\n    _addShapes: function _addShapes() {\n      this._shape1 = new L.PatternRect({\n        stroke: false,\n        fillOpacity: this.options.fillOpacity,\n        color: this.options.color,\n        fill: this.options.color,\n        x: 0,\n        y: 0,\n        width: this.options.width / 2,\n        height: this.options.height / 2\n      });\n      this._shape2 = new L.PatternRect({\n        stroke: false,\n        fillOpacity: this.options.fillOpacity,\n        color: this.options.color,\n        fill: this.options.color,\n        x: this.options.width / 2,\n        y: this.options.height / 2,\n        width: this.options.width / 2,\n        height: this.options.height / 2\n      });\n      this.addShape(this._shape1);\n      this.addShape(this._shape2);\n\n      this._update();\n    },\n    _update: function _update() {},\n    setStyle: L.Pattern.prototype.setStyle\n  });\n})(window, document);\n\nvar L$1 = window.L;\n/**\n * **key**: {string} - required.<br/>\n * **weight**: {number} (default: 4) - The width of the primary stripe.<br/>\n * **spaceWeight**: {number} (default: 4) - The width of the secondaty stripe, typically an empty space.<br/>\n * **color**: {color} (default: #000000) - The color of the primary stripe.<br/>\n * **spaceColor**: {color} (default: #ffffff) - The color of the secondary stripe.<br/>\n * **opacity**: {0.0 - 1.0} (default: 1.0) - The opacity of the primary stripe.<br/>\n * **spaceOpacity**: {0.0 - 1.0} (default: 0.0) - The opacity of the secondary stripe.<br/>\n *\n * @see See [API](https://github.com/teastman/Leaflet.pattern#stripes) for a list of properties\n * @component\n */\n\nvar StripePattern = function StripePattern(options) {\n  return new L$1.StripePattern(options);\n};\n\nvar L$2 = window.L;\n\nvar BasePattern = function BasePattern(options, Shape) {\n  var shape = new Shape(options);\n  var pattern = new L$2.Pattern(options);\n  pattern.addShape(shape);\n  return pattern;\n};\n\nvar L$3 = window.L;\n/**\n * **key**: {string} - required.<br/>\n * **x**: {number} (default: 0) - x offset of the circle.<br/>\n * **y**: {number} (default: 0) - y offset of the circle.<br/>\n * **radius**: {number} (default: 0) - radius of the circle.<br/>\n\n * @see See [API](https://github.com/teastman/Leaflet.pattern#circle) for a list of properties\n * @component\n */\n\nvar CirclePattern = function CirclePattern(options) {\n  return BasePattern(options, L$3.PatternCircle);\n};\n\nvar L$4 = window.L;\n/**\n * **key**: {string} - required.<br/>\n * **x**: {number} (default: 0) - x offset of the rectangle.<br/>\n * **y**: {number} (default: 0) - y offset of the rectangle.<br/>\n * **width**: {number} (default: 10) - width of the rectangle.<br/>\n * **height**: {number} (default: 10) - height of the rectangle.<br/>\n * **rx**: {number} (default: null) - x radius for rounded corners.<br/>\n * **ry**: {number} (default: null) - y radius for rounded corners.<br/>\n\n * @see See [API](https://github.com/teastman/Leaflet.pattern#rectangle) for a list of properties\n * @component\n */\n\nvar RectPattern = function RectPattern(options) {\n  return BasePattern(options, L$4.PatternRect);\n};\n\nvar L$5 = window.L;\n/**\n * **key** {string} - required.<br/>\n * **d** {path} (default: null) - The SVG path definition.\n * @see See [API](https://github.com/teastman/Leaflet.pattern#path) for a list of properties\n * @component\n */\n\nvar PathPattern = function PathPattern(options) {\n  return BasePattern(options, L$5.PatternPath);\n};\n\nvar L$6 = window.L;\n/**\n * **key**: {string} - required.<br/>\n * **width**: {number} (default: 12) - The width of the square.<br/>\n * **height**: {number} (default: 12) - The height of the square.<br/>\n * **color**: {color} (default: #000000) - The color of the square.<br/>\n * **fillOpacity**: {number} (default: 1) - The opacity of the primary square.<br/>\n\n * @component\n */\n\nvar CheckerBoardPattern = function CheckerBoardPattern(options) {\n  return new L$6.CheckerBoardPattern(options);\n};\n\nvar index = {\n  StripePattern: StripePattern,\n  CirclePattern: CirclePattern,\n  RectPattern: RectPattern,\n  PathPattern: PathPattern,\n  CheckerBoardPattern: CheckerBoardPattern\n};\nexport { GeoJSONFillable$1 as GeoJSONFillable, index as Patterns };","map":{"version":3,"sources":["../node_modules/lodash.isfunction/index.js","../src/GeoJSONFillable.js","../src/patterns/leaflet.pattern.js","../src/patterns/StripePattern.js","../src/patterns/BasePattern.js","../src/patterns/CirclePattern.js","../src/patterns/RectPattern.js","../src/patterns/PathPattern.js","../src/patterns/CheckerBoardPattern.js","../src/patterns/index.js"],"names":["global","Symbol","GeoJSONFillable","Path","props","el","e","fromProps","toProps","isFunction","addedNotExistedPatterns","map","featureStyle","style","layer","pattern","fillPattern","addPatternToLayer","withLeaflet","getId","id","value","L","window","options","Error","document","dom","transform","renderer","opacity","spaceOpacity","setStyle","StripePattern","BasePattern","shape","CirclePattern","RectPattern","PathPattern","CheckerBoardPattern"],"mappings":"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","sourcesContent":["/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    nullTag = '[object Null]',\n    proxyTag = '[object Proxy]',\n    undefinedTag = '[object Undefined]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isFunction;\n","import { Path, withLeaflet } from 'react-leaflet';\nimport { GeoJSON as LeafletGeoJSON } from 'leaflet';\nimport isFunction from 'lodash.isfunction';\n\n/**\n * GeoJSON supported fillPattern style\n */\nclass GeoJSONFillable extends Path {\n  createLeafletElement(props) {\n    const el = new LeafletGeoJSON(props.data, this.getOptions(props));\n    el.once('add', e => {\n      this.addedNotExistedPatterns(e.target.getLayers(), props.style);\n    });\n    return el;\n  }\n\n  updateLeafletElement(fromProps, toProps) {\n    if (isFunction(toProps.style)) {\n      this.addedNotExistedPatterns(\n        this.leafletElement.getLayers(),\n        toProps.style\n      );\n      this.setStyle(toProps.style);\n    } else {\n      if (fromProps.style.fillPattern !== toProps.style.fillPattern) {\n        this.addPatternToLayer(toProps.style.fillPattern, this);\n      }\n      this.setStyleIfChanged(fromProps, toProps);\n    }\n  }\n\n  addedNotExistedPatterns = (layers, style) => {\n    const {\n      leaflet: { map },\n    } = this.props;\n    if (!style) return;\n    if (isFunction(style))\n      layers.forEach(layer => {\n        const featureStyle = style(layer.feature);\n        if (\n          featureStyle.fillPattern &&\n          !map.hasPattern(featureStyle.fillPattern)\n        ) {\n          map.once('patternadd', ({ pattern }) => {\n            // console.log('added', pattern, layer);\n            setTimeout(() => layer.setStyle({ fillPattern: pattern }), 0);\n          });\n          map.addPattern(featureStyle.fillPattern);\n        }\n      });\n    else if (style.fillPattern) {\n      this.addPatternToLayer(style.fillPattern, this);\n    }\n  };\n  addPatternToLayer = (pattern, layer) => {\n    const {\n      leaflet: { map },\n    } = this.props;\n    if (!map.hasPattern(pattern)) {\n      map.once('patternadd', ({ pattern }) => {\n        setTimeout(() => layer.setStyle({ fillPattern: pattern }), 0);\n      });\n      map.addPattern(pattern);\n    } else {\n      layer.setStyle({ fillPattern: pattern });\n    }\n  };\n}\n/** @component */\nexport default withLeaflet(GeoJSONFillable);\n","/*\n Leaflet.pattern, Provides tools to set the backgrounds of vector shapes in Leaflet to be patterns.\n https://github.com/teastman/Leaflet.pattern\n (c) 2015, Tyler Eastman\n*/\nlet getId = value => {\n  const id = value.options.key || L.stamp(value)\n  return id\n}\nlet L = window.L;\n\n(function(window, document, undefined) {\n  /*\n * L.Pattern is the base class for fill patterns for leaflet Paths.\n */\n\n  L.Pattern = L.Class.extend({\n    includes: L.Evented.prototype || L.Mixin.Events,\n\n    options: {\n      x: 0,\n      y: 0,\n      width: 8,\n      height: 8,\n      patternUnits: 'userSpaceOnUse',\n      patternContentUnits: 'userSpaceOnUse',\n      key: ''\n      // angle: <0 - 360>\n      // patternTransform: <transform-list>\n    },\n\n    _addShapes: L.Util.falseFn,\n    _update: L.Util.falseFn,\n\n    initialize: function(options) {\n      this._shapes = {}\n      if (!options.key) throw Error('Should define a unique option key')\n      L.setOptions(this, options)\n    },\n\n    onAdd: function(map) {\n      this._map = map.target ? map.target : map\n      if (!this._map._initDefRoot) {\n        debugger\n      }\n      this._map._initDefRoot()\n\n      // Create the DOM Object for the pattern.\n      this._initDom()\n\n      // Any shapes that were added before this was added to the map need to have their onAdd called.\n      for (var i in this._shapes) {\n        this._shapes[i].onAdd(this)\n      }\n\n      // Call any children that want to add their own shapes.\n      this._addShapes()\n\n      // Add the DOM Object to the DOM Tree\n      this._addDom()\n      this.redraw()\n\n      if (this.getEvents) {\n        this._map.on(this.getEvents(), this)\n      }\n      this.fire('add')\n      this._map.fire('patternadd', { pattern: this })\n    },\n\n    onRemove: function() {\n      this._removeDom()\n    },\n\n    redraw: function() {\n      if (this._map) {\n        this._update()\n        for (var i in this._shapes) {\n          this._shapes[i].redraw()\n        }\n      }\n      return this\n    },\n\n    setStyle: function(style) {\n      L.setOptions(this, style)\n      if (this._map) {\n        this._updateStyle()\n        this.redraw()\n      }\n      return this\n    },\n\n    addTo: function(map) {\n      map.addPattern(this)\n      return this\n    },\n\n    remove: function() {\n      return this.removeFrom(this._map)\n    },\n\n    removeFrom: function(map) {\n      if (map) {\n        map.removePattern(this)\n      }\n      return this\n    }\n  })\n\n  L.Map.addInitHook(function() {\n    this._patterns = {}\n  })\n\n  L.Map.include({\n    addPattern: function(pattern) {\n      var id = getId(pattern)\n      if (this._patterns[id]) {\n        return pattern\n      }\n      this._patterns[id] = pattern\n\n      this.whenReady(pattern.onAdd, pattern)\n      return this\n    },\n\n    removePattern: function(pattern) {\n      var id = getId(pattern)\n      if (!this._patterns[id]) {\n        return this\n      }\n\n      if (this._loaded) {\n        pattern.onRemove(this)\n      }\n\n      if (pattern.getEvents) {\n        this.off(pattern.getEvents(), pattern)\n      }\n\n      delete this._patterns[id]\n\n      if (this._loaded) {\n        this.fire('patternremove', { pattern: pattern })\n        pattern.fire('remove')\n      }\n\n      pattern._map = null\n      return this\n    },\n\n    hasPattern: function(pattern) {\n      return !!pattern && getId(pattern) in this._patterns\n    }\n  })\n\n  L.Pattern.SVG_NS = 'http://www.w3.org/2000/svg'\n\n  L.Pattern = L.Pattern.extend({\n    _createElement: function(name) {\n      return document.createElementNS(L.Pattern.SVG_NS, name)\n    },\n\n    _initDom: function() {\n      this._dom = this._createElement('pattern')\n      if (this.options.className) {\n        L.DomUtil.addClass(this._dom, this.options.className)\n      }\n      this._updateStyle()\n    },\n\n    _addDom: function() {\n      this._map._defRoot.appendChild(this._dom)\n    },\n\n    _removeDom: function() {\n      L.DomUtil.remove(this._dom)\n    },\n\n    _updateStyle: function() {\n      var dom = this._dom\n\n      var options = this.options\n\n      if (!dom) {\n        return\n      }\n\n      dom.setAttribute('id', getId(this))\n      dom.setAttribute('x', options.x)\n      dom.setAttribute('y', options.y)\n      dom.setAttribute('width', options.width)\n      dom.setAttribute('height', options.height)\n      dom.setAttribute('patternUnits', options.patternUnits)\n      dom.setAttribute('patternContentUnits', options.patternContentUnits)\n\n      if (options.patternTransform || options.angle) {\n        var transform = options.patternTransform\n          ? options.patternTransform + ' '\n          : ''\n        transform += options.angle ? 'rotate(' + options.angle + ') ' : ''\n        dom.setAttribute('patternTransform', transform)\n      } else {\n        dom.removeAttribute('patternTransform')\n      }\n\n      for (var i in this._shapes) {\n        this._shapes[i]._updateStyle()\n      }\n    }\n  })\n\n  L.Map.include({\n    _initDefRoot: function() {\n      if (!this._defRoot) {\n        if (typeof this.getRenderer === 'function') {\n          var renderer = this.getRenderer(this)\n          this._defRoot = L.Pattern.prototype._createElement('defs')\n          renderer._container.appendChild(this._defRoot)\n        } else {\n          if (!this._pathRoot) {\n            this._initPathRoot()\n          }\n          this._defRoot = L.Pattern.prototype._createElement('defs')\n          this._pathRoot.appendChild(this._defRoot)\n        }\n      }\n    }\n  })\n\n  if (L.SVG) {\n    L.SVG.include({\n      _superUpdateStyle: L.SVG.prototype._updateStyle,\n\n      _updateStyle: function(layer) {\n        this._superUpdateStyle(layer)\n\n        if (layer.options.fill && layer.options.fillPattern) {\n          layer._path.setAttribute(\n            'fill',\n            'url(#' + getId(layer.options.fillPattern) + ')'\n          )\n        }\n      }\n    })\n  } else {\n    L.Path.include({\n      _superUpdateStyle: L.Path.prototype._updateStyle,\n\n      _updateStyle: function() {\n        this._superUpdateStyle()\n\n        if (this.options.fill && this.options.fillPattern) {\n          this._path.setAttribute(\n            'fill',\n            'url(#' + getId(this.options.fillPattern) + ')'\n          )\n        }\n      }\n    })\n  }\n\n  /*\n     * L.StripePattern is an implementation of Pattern that creates stripes.\n     */\n\n  L.StripePattern = L.Pattern.extend({\n    options: {\n      weight: 4,\n      spaceWeight: 4,\n      color: '#000000',\n      spaceColor: '#ffffff',\n      opacity: 1.0,\n      spaceOpacity: 0.0\n    },\n\n    _addShapes: function() {\n      this._stripe = new L.PatternPath({\n        stroke: true,\n        weight: this.options.weight,\n        color: this.options.color,\n        opacity: this.options.opacity\n      })\n\n      this._space = new L.PatternPath({\n        stroke: true,\n        weight: this.options.spaceWeight,\n        color: this.options.spaceColor,\n        opacity: this.options.spaceOpacity\n      })\n\n      this.addShape(this._stripe)\n      this.addShape(this._space)\n\n      this._update()\n    },\n\n    _update: function() {\n      this._stripe.options.d =\n        'M0 ' + this._stripe.options.weight / 2 + ' H ' + this.options.width\n      this._space.options.d =\n        'M0 ' +\n        (this._stripe.options.weight + this._space.options.weight / 2) +\n        ' H ' +\n        this.options.width\n    },\n\n    setStyle: L.Pattern.prototype.setStyle\n  })\n\n  L.stripePattern = function(options) {\n    return new L.StripePattern(options)\n  }\n\n  /*\n     * L.PatternShape is the base class that is used to define the shapes in Patterns.\n     */\n\n  L.PatternShape = L.Class.extend({\n    options: {\n      stroke: true,\n      color: '#3388ff',\n      weight: 3,\n      opacity: 1,\n      lineCap: 'round',\n      lineJoin: 'round',\n      // dashArray: null\n      // dashOffset: null\n\n      // fill: false\n      // fillColor: same as color by default\n      fillOpacity: 0.2,\n      fillRule: 'evenodd'\n      // fillPattern: L.Pattern\n    },\n\n    initialize: function(options) {\n      L.setOptions(this, options)\n    },\n\n    // Called when the parent Pattern get's added to the map,\n    // or when added to a Pattern that is already on the map.\n    onAdd: function(pattern) {\n      this._pattern = pattern\n      if (this._pattern._dom) {\n        this._initDom() // This function is implemented by it's children.\n        this._addDom()\n      }\n    },\n\n    addTo: function(pattern) {\n      pattern.addShape(this)\n      return this\n    },\n\n    redraw: function() {\n      if (this._pattern) {\n        this._updateShape() // This function is implemented by it's children.\n      }\n      return this\n    },\n\n    setStyle: function(style) {\n      L.setOptions(this, style)\n      if (this._pattern) {\n        this._updateStyle()\n      }\n      return this\n    },\n\n    setShape: function(shape) {\n      this.options = L.extend({}, this.options, shape)\n      this._updateShape()\n    }\n  })\n\n  L.Pattern.include({\n    addShape: function(shape) {\n      var id = getId(shape)\n      if (this._shapes[id]) {\n        return shape\n      }\n      this._shapes[id] = shape\n      shape.onAdd(this)\n    }\n  })\n\n  L.PatternShape.SVG_NS = 'http://www.w3.org/2000/svg'\n\n  L.PatternShape = L.PatternShape.extend({\n    _createElement: function(name) {\n      return document.createElementNS(L.PatternShape.SVG_NS, name)\n    },\n\n    _initDom: L.Util.falseFn,\n    _updateShape: L.Util.falseFn,\n\n    _initDomElement: function(type) {\n      this._dom = this._createElement(type)\n      if (this.options.className) {\n        L.DomUtil.addClass(this._dom, this.options.className)\n      }\n      this._updateStyle()\n    },\n\n    _addDom: function() {\n      this._pattern._dom.appendChild(this._dom)\n    },\n\n    _updateStyle: function() {\n      var dom = this._dom\n\n      var options = this.options\n\n      if (!dom) {\n        return\n      }\n\n      if (options.stroke) {\n        dom.setAttribute('stroke', options.color)\n        dom.setAttribute('stroke-opacity', options.opacity)\n        dom.setAttribute('stroke-width', options.weight)\n        dom.setAttribute('stroke-linecap', options.lineCap)\n        dom.setAttribute('stroke-linejoin', options.lineJoin)\n\n        if (options.dashArray) {\n          dom.setAttribute('stroke-dasharray', options.dashArray)\n        } else {\n          dom.removeAttribute('stroke-dasharray')\n        }\n\n        if (options.dashOffset) {\n          dom.setAttribute('stroke-dashoffset', options.dashOffset)\n        } else {\n          dom.removeAttribute('stroke-dashoffset')\n        }\n      } else {\n        dom.setAttribute('stroke', 'none')\n      }\n\n      if (options.fill) {\n        if (options.fillPattern) {\n          dom.setAttribute('fill', 'url(#' + getId(options.fillPattern) + ')')\n        } else {\n          dom.setAttribute('fill', options.fillColor || options.color)\n        }\n        dom.setAttribute('fill-opacity', options.fillOpacity)\n        dom.setAttribute('fill-rule', options.fillRule || 'evenodd')\n      } else {\n        dom.setAttribute('fill', 'none')\n      }\n\n      dom.setAttribute(\n        'pointer-events',\n        options.pointerEvents ||\n          (options.interactive ? 'visiblePainted' : 'none')\n      )\n    }\n  })\n\n  /*\n     * L.PatternPath is the implementation of PatternShape for adding Paths\n     */\n\n  L.PatternPath = L.PatternShape.extend({\n    //\toptions: {\n    // d: <svg path code>\n    //\t},\n\n    _initDom: function() {\n      this._initDomElement('path')\n    },\n\n    _updateShape: function() {\n      if (!this._dom) {\n        return\n      }\n      this._dom.setAttribute('d', this.options.d)\n    }\n  })\n\n  /*\n     * L.PatternCircle is the implementation of PatternShape for adding Circles\n     */\n\n  L.PatternCircle = L.PatternShape.extend({\n    options: {\n      x: 0,\n      y: 0,\n      radius: 0\n    },\n\n    _initDom: function() {\n      this._initDomElement('circle')\n    },\n\n    _updateShape: function() {\n      if (!this._dom) {\n        return\n      }\n      this._dom.setAttribute('cx', this.options.x)\n      this._dom.setAttribute('cy', this.options.y)\n      this._dom.setAttribute('r', this.options.radius)\n    }\n  })\n\n  /*\n     * L.PatternRect is the implementation of PatternShape for adding Rectangles\n     */\n\n  L.PatternRect = L.PatternShape.extend({\n    options: {\n      x: 0,\n      y: 0,\n      width: 10,\n      height: 10\n      // rx: x radius for rounded corners\n      // ry: y radius for rounded corners\n    },\n\n    _initDom: function() {\n      this._initDomElement('rect')\n    },\n\n    _updateShape: function() {\n      if (!this._dom) {\n        return\n      }\n      this._dom.setAttribute('x', this.options.x)\n      this._dom.setAttribute('y', this.options.y)\n      this._dom.setAttribute('width', this.options.width)\n      this._dom.setAttribute('height', this.options.height)\n      if (this.options.rx) {\n        this._dom.setAttribute('rx', this.options.rx)\n      }\n      if (this.options.ry) {\n        this._dom.setAttribute('ry', this.options.ry)\n      }\n    }\n  })\n\n  L.CheckerBoardPattern = L.Pattern.extend({\n    options: {\n      color: '#000000',\n      fillOpacity: 1\n    },\n\n    _addShapes: function() {\n      this._shape1 = new L.PatternRect({\n        stroke: false,\n        fillOpacity: this.options.fillOpacity,\n        color: this.options.color,\n        fill: this.options.color,\n        x: 0,\n        y: 0,\n        width: this.options.width / 2,\n        height: this.options.height / 2\n      })\n\n      this._shape2 = new L.PatternRect({\n        stroke: false,\n        fillOpacity: this.options.fillOpacity,\n        color: this.options.color,\n        fill: this.options.color,\n        x: this.options.width / 2,\n        y: this.options.height / 2,\n        width: this.options.width / 2,\n        height: this.options.height / 2\n      })\n\n      this.addShape(this._shape1)\n      this.addShape(this._shape2)\n\n      this._update()\n    },\n\n    _update: function() {\n\n    },\n\n    setStyle: L.Pattern.prototype.setStyle\n  })\n})(window, document)\n","const L = window.L;\n\n/**\n * **key**: {string} - required.<br/>\n * **weight**: {number} (default: 4) - The width of the primary stripe.<br/>\n * **spaceWeight**: {number} (default: 4) - The width of the secondaty stripe, typically an empty space.<br/>\n * **color**: {color} (default: #000000) - The color of the primary stripe.<br/>\n * **spaceColor**: {color} (default: #ffffff) - The color of the secondary stripe.<br/>\n * **opacity**: {0.0 - 1.0} (default: 1.0) - The opacity of the primary stripe.<br/>\n * **spaceOpacity**: {0.0 - 1.0} (default: 0.0) - The opacity of the secondary stripe.<br/>\n *\n * @see See [API](https://github.com/teastman/Leaflet.pattern#stripes) for a list of properties\n * @component\n */\nexport const StripePattern = options => new L.StripePattern(options);\n","const L = window.L\nexport const BasePattern = (options, Shape) => {\n  const shape = new Shape(options)\n  const pattern = new L.Pattern(options)\n  pattern.addShape(shape)\n  return pattern\n}\n","import { BasePattern } from './BasePattern'\n\nconst L = window.L\n\n/**\n * **key**: {string} - required.<br/>\n * **x**: {number} (default: 0) - x offset of the circle.<br/>\n * **y**: {number} (default: 0) - y offset of the circle.<br/>\n * **radius**: {number} (default: 0) - radius of the circle.<br/>\n\n * @see See [API](https://github.com/teastman/Leaflet.pattern#circle) for a list of properties\n * @component\n */\nexport const CirclePattern = options => BasePattern(options, L.PatternCircle);\n","import { BasePattern } from './BasePattern';\n\nconst L = window.L;\n\n/**\n * **key**: {string} - required.<br/>\n * **x**: {number} (default: 0) - x offset of the rectangle.<br/>\n * **y**: {number} (default: 0) - y offset of the rectangle.<br/>\n * **width**: {number} (default: 10) - width of the rectangle.<br/>\n * **height**: {number} (default: 10) - height of the rectangle.<br/>\n * **rx**: {number} (default: null) - x radius for rounded corners.<br/>\n * **ry**: {number} (default: null) - y radius for rounded corners.<br/>\n\n * @see See [API](https://github.com/teastman/Leaflet.pattern#rectangle) for a list of properties\n * @component\n */\nexport const RectPattern = options => BasePattern(options, L.PatternRect);\n","import { BasePattern } from './BasePattern';\n\nconst L = window.L;\n\n/**\n * **key** {string} - required.<br/>\n * **d** {path} (default: null) - The SVG path definition.\n * @see See [API](https://github.com/teastman/Leaflet.pattern#path) for a list of properties\n * @component\n */\nexport const PathPattern = options => BasePattern(options, L.PatternPath);\n","const L = window.L\n\n/**\n * **key**: {string} - required.<br/>\n * **width**: {number} (default: 12) - The width of the square.<br/>\n * **height**: {number} (default: 12) - The height of the square.<br/>\n * **color**: {color} (default: #000000) - The color of the square.<br/>\n * **fillOpacity**: {number} (default: 1) - The opacity of the primary square.<br/>\n\n * @component\n */\nexport const CheckerBoardPattern = (options) => new L.CheckerBoardPattern(options)\n","import './leaflet.pattern'\nimport { StripePattern } from './StripePattern'\nimport { CirclePattern } from './CirclePattern'\nimport { RectPattern } from './RectPattern'\nimport { PathPattern } from './PathPattern'\nimport {CheckerBoardPattern} from './CheckerBoardPattern'\nexport default { StripePattern, CirclePattern, RectPattern, PathPattern, CheckerBoardPattern }\n"]},"metadata":{},"sourceType":"module"}